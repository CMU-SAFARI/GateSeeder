use std::env::args;
use std::error::Error;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

fn main() -> Result<(), Box<dyn Error>> {
	let args: Vec<_> = args().collect();
	let path = Path::new(&args[1]);
	let file = File::open(&path)?;
	let mut lines = BufReader::new(&file).lines();
	let line = lines.next().unwrap();
	let se_w: u32 = line?.parse()?;
	let line = lines.next().unwrap();
	let se_k: u32 = line?.parse()?;
	let line = lines.next().unwrap();
	let mut map_size: u32 = line?.parse()?;

	println!(
		"// Autogenerated file
// w: {}
// k: {}
// map_size: {}
#ifndef AUTO_GEN_HPP
#define AUTO_GEN_HPP",
		se_w, se_k, map_size
	);

	println!(
		"#include \"ap_int.h\"
#include <cstdint>"
	);

	if map_size > 2 * se_k {
		map_size = 2 * se_k;
	}

	println!(
		"#define SE_W {}
#define SE_K {}
#define MAP_SIZE {}
#define READ_SIZE 22",
		se_w, se_k, map_size
	);

	println!(
		"#define GET_MIN(min, window) \\
	{{ \\"
	);
	for i in 0..se_w {
		println!("		const seed_t min_{} = window[{}]; \\", i, i);
	}

	let mut i = se_w;
	let mut j = se_w;
	let mut k = 0;
	while i > 1 {
		let r = i % 2;
		i = i / 2;
		for _ in 0..i {
			println!(
				"		const seed_t min_{} = (min_{}.hash <= min_{}.hash) ? min_{} : min_{}; \\",
				j,
				k,
				k + 1,
				k,
				k + 1
			);
			j += 1;
			k += 2;
		}
		if r == 1 {
			println!("		const seed_t min_{} = min_{}; \\", j, k);
			j += 1;
			k += 1;
			i += 1;
		}
	}
	println!("		min = min_{}; \\", j - 1);

	println!("	}}");

	println!("const static unsigned bucket_id_msb = MAP_SIZE - 1;");

	if 2 * se_k > map_size {
		println!(
			"const static unsigned seed_id_lsb   = MAP_SIZE;
const static unsigned seed_id_msb   = 2 * SE_K - 1;
const static unsigned seed_id_size  = seed_id_msb - bucket_id_msb;
#define KEY_SEED_ID_START 43"
		);

		println!(
			"struct ms_pos_t {{
	uint32_t start_pos;
	uint32_t end_pos;
	ap_uint<seed_id_size> seed_id;
	ap_uint<READ_SIZE> query_loc;
	ap_uint<1> str;
	ap_uint<1> EOR;
}};"
		);

		println!(
			"#define PUSH_EOR(stream) stream << ms_pos_t{{.start_pos = 0, .end_pos = 0, .seed_id = 0, .query_loc = 0, .str = 0, .EOR = 1}};"
		);

		println!(
			"#define PUSH_EOF(stream) stream << ms_pos_t{{.start_pos = 0, .end_pos = 0, .seed_id = 0, .query_loc = 0, .str = 1, .EOR = 1}};"
		);

		println!(
			"#define PUSH_POS(stream, start, end, seed) stream << ms_pos_t{{.start_pos = start, .end_pos = end, .seed_id = seed.hash(seed_id_msb, seed_id_lsb), .query_loc = seed.loc, .str = seed.str, .EOR = 0}};"
		);

		println!(
			"#define PUSH_LOC(stream, key, pos) \\
	{{ \\
		const ap_uint<64> uint_key = ap_uint<64>(key); \\
		const ap_uint<seed_id_size> seed_id = uint_key.range(seed_id_size - 1 + KEY_SEED_ID_START, KEY_SEED_ID_START); \\
		if (seed_id == pos.seed_id) {{ \\
			const uint64_t loc = key_2_loc(key, pos.str, pos.query_loc); \\
			loc_o << loc; \\
		}} \\
	}}"
		);
	} else {
		println!(
			"struct ms_pos_t {{
	uint32_t start_pos;
	uint32_t end_pos;
	ap_uint<READ_SIZE> query_loc;
	ap_uint<1> str;
	ap_uint<1> EOR;
}};"
		);

		println!("#define PUSH_EOR(stream) stream << ms_pos_t{{.start_pos = 0, .end_pos = 0, .query_loc = 0, .str = 0, .EOR = 1}};"
		);

		println!("#define PUSH_EOF(stream) stream << ms_pos_t{{.start_pos = 0, .end_pos = 0, .query_loc = 0, .str = 1, .EOR = 1}};"
		);

		println!("#define PUSH_POS(stream, start, end, seed) stream << ms_pos_t{{.start_pos = start, .end_pos = end, .query_loc = seed.loc, .str = seed.str, .EOR = 0}};"
		);

		println!(
			"#define PUSH_LOC(stream, key, pos) \\
	{{ \\
		const uint64_t loc = key_2_loc(key, pos.str, pos.query_loc); \\
		loc_o << loc; \\
	}}"
		);
	}

	println!("#endif");

	Ok(())
}
